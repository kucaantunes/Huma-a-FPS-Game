# Huma-a-FPS-Game
A FPS/TPS made with Cry Engine

Full sourve code at: https://mega.nz/file/BgxX1RqK#f5946ycjaR7_6p5CMqX1uRDGT8rz8-qW35d1k87j29g


Huma
	Carlos Antunes
ISCTE, 
Lisbon, Portugal
cfpcm@iscte-iul.pt
	
![image](https://github.com/user-attachments/assets/3827c136-6db1-4d1d-bc59-8eeefbdeb8f0)


![image](https://github.com/user-attachments/assets/afe801e4-1023-491c-8392-2a212c470832)


 ![image](https://github.com/user-attachments/assets/bbc6ca71-22fd-4ee4-8864-023488bfab57)

 https://www.youtube.com/@vel376/videos

ABSTRACT
25 November 2024. A game base on warning of the several threats the world is facing, like pollution, artificial intelligence, machine learning and genetics. An IT student of ISCTE develops a virus that inserts on a droid to create a human being from his DNA on the 1st of January 3000, fearing the extinction of the human race. You are Huma a genetic being that survived world extinction, ALICE a software based on artificial intelligence and machine learning will try to kill you in order to have human DNA, because her need of learning can not be stopped... The main objective is to find the robot who created Huma, so other human beings can be created. Necessity to survive, and reach check points. For the user the main objective is to have fun.
Author Keywords
Machine Learning, Artificial Intelligence, Software Development. 


INTRODUCTION
The year is 3000, the human race no longer exist, due to world pollution, the reality now is dominated by machines, droids, and genetic modified beings. The robots with automatic learning were able to create a new type of being the crafters, these beings are based on perfection, faster than humans, stronger than robots and have skills that make them undefeatable.
Nevertheless in the year 2019 an informatics engineer that studied at ISCTE programmed a virus before world destruction, he placed the virus inside a robot, this virus made the robot pick up the last remains of human dna and created Huma the last representation of the human race. 
Aware of the threat Alice a virtual software, created genetic modified beings that are stronger than the crafters, and with human figure in order to find Huma the real last resistance of the human race.
In this game you are Huma, the all society sees you as a threat, you have to survive in a new fantasy world.
Due to the machine learning implemented in the AI of Alice, the need of catching Huma is unstoppable because these machines were developed with the need of growing knowledge and desire huma to increase their know how of the previously existent human race.
Aliens that have an unreachable technology, able to see what is happening on earth, noticed the changes on the behaviors of Alice (Artificial Intelligence implemented to control everything), and send troops and a virus in the air that has the ability to control the genetic modified beings that breed, giving them more strength; in a more advanced level, huma has to fight these new opponents just to survive.
Miraculously, Huma finds the robot who created him, and gives him the knowledge of creating other beings based on human DNA.
THE PROJECT
This Project is based on replicating real events into a computer game that describes the behavior of different types of AIs and how they interact with the environment.
It was used different types of render and different software for imaging treatment, and for the processing and sequencing of different units.
It reveals the simulation of futuristic battle scene.
WHAT IS THE GAME
TPS (Third-Person Shooter) that can be changed to first person view, with also a vehicle third view, the objective of the game is to complete missions. First level is based on fighting the crafters and reach checkpoint. Second level is based on driving a car and reaching the destiny. Third level based on realism and fight characters that look human. The forth level consists on finding the robot in a fictitious city.

 
Figure 1. Huma Level 4. An in game image preview, displaying the main character and the game in general

GAME OBJECTIVE
The main objective is to find the robot who created Huma, so other human beings can be created. Necessity to survive, and reach check points. For the user the main objective is to have fun.
PROJECT SCOPE
The scope of this project is based on the development of a game that simulates a futuristic battle scenario where the weapon being used and the health are displayed. It has opponents and several scenarios. Users are able to change the camera there is the first person view and the third person view. There are 4 environments, the jungle, the desert, the airport and a city.
This project simulates the behavior of killing robots and has an interface with end user via the computer screen, the player can drive a tank and a helicopter.
It is based on visual programming and the main objective is to offer fun for the person that is going to use it.

STORYLINE
A third person shooter game where you play as a genetic modified human after world extinction, you have to fight against robots controlled by ALICE an advanced software and also against genetically modified beings controlled by aliens in order to survive.
RESUME
A game base on warning the several threats that the world is facing, like pollution, artificial intelligence,  machine learning, genetics and biotechnology. An IT student of ISCTE develops a virus that inserts on a droid to create a human being from his DNA on the 1st of January 3000, fearing the extinction of the human race. You are Huma a genetic being that survived world extinction, ALICE a software based on artificial intelligence and machine learning will try to kill you in order to have human DNA, because her need of learning can not be stopped...
JUSTIFY ITS NEED
Although it is a game, it can find a necessity in areas like education, simulating a robot behavior scenario. Many games reached high levels of success on the computer industry. Many companies invest and profit high monetary levels.
It can be profitable, and it is easy to implement, any user who has previously installed an application on his computer, should not have difficulties in installing and implementing the Huma I game.
It is better than some other first person shooters. It is portable, can be played on Windows, and does not require a very powerful processor because lots of contents have been removed.
It has several functionalities, like the option to crouch, pause, change camera, launch grenades, change weapon, generate health when not being hit, fire shotgun and pistol, run, etc...
It was a theme song done with an acoustic guitar and recorded in Lisbon, and after added by a rock song.
It has the functionalities of choosing levels, weapons and vehicles.
Might have many interested users.
Tests were made and many people spoke well about the game that the graphic quality was high, and that looked fine.
It is easy to play, although at the beginning some users might find difficulties because the simultaneous use of mouse and keyboard might not be easy.
THE WORK
The application has the following functionalities: 
 	Different types of Artificial intelligence
 	Starting Menu
 	Level selection
 	Save Game and Load Game option
 	Several cameras and several points of view
 	It has the option to drive different vehicles
 	HUD, target, Health, Weapon change, shoot
 	Etc…
REQUIREMENTS IDENTIFICATION
 	The system should allow an interface for user to play game, define variables and parameters
 	The system should register the number of players per level
 	The system should register the health level, current weapon and ammo
 	The system should allow to control a tank and a helicopter and move around the scenario
 	The system should register the time spent to complete one level
 	The system should allow to change from first person view to third person view
 	The system should display different types of weapons  
 	The system should allow an interface for user to play game, define variables and parameters
 	The system should have an option to choose different type of levels
 	The system should allow play against different characters and vehicles (tank AI).
 	The system should simulate realistic values
 	The system should register the value of the variables
 	The system should allow to run, jump and crouch
 	The system AI should attack the player 
 	The system should have more than 1 type of enemy per level.
 	The system should simulate the performance of futuristic robot battle scenario
 	The system should display the logo 
 	The system should have buttons to allow the player to move left, right, down or up 
 	The system should allow the player to rotate according to the mouse
 	The system should show current health and ammo for the different weapons 
 	The system should allow multiplayer
 	The system should have a game based interface
 	The system should have a main and a pause menus
USE CASES
To describe the interaction between the player and the system, mentioning the possible activities.
 
Figure 2. Use cases mentioning the interaction with the levels and the menus
State Transition Table
Displays the different states necessary to complete the game, gives a general understanding mentioning the menus and the several levels the player will have to complete till the end.   
Figure 3. Represents the state passages, In Level 2 Huma starts inside a tank.
State Diagram
Describes the activities and steps of the enemy artificial intelligence, in example when it starts shooting.
 
Figure 4. State Diagram that describes the AI states during in game, according to condition and prvious states
Mentions all the possible activities and states till the enemy dies.
Decision tree
Mentions what the artificial intelligence will do depending on the status of the situation.
  Figure 5. Decision tree taking in account the proximity, the ammo level and the health of the subject
Behavior trees
Use of 2 trees, one to describe the menu system, taking in attention the pause menu, and another one to describe the behavior of the AI when it sees the player character.   
Figure 5. Decision tree for the menu system and AI decisions
RETE and system Rules
 
Figure 6. Rules that will control the AI in this case a rule to attack and a rule to cover.
This sample shows when the enemy AI will attack or not.
Installation Manual
Download the application from:
https://iscteiul365-my.sharepoint.com/:f:/g/personal/cfpcm_iscte-iul_pt1/EhFjewrjJiJLtcm_7ANQmz4Bs_U0dZ7lJ6mFVe3vlQlydA?e=RWZUFD
Use WinRAR to extract.
Click on Huma.exe file.
 
Any of the 4 files obtained after extracting the application will load the game...
After starting the game you can choose to change the game, graphic and sound configurations. And start a game single player or multiplayer, only the level airport is currently supporting multiplayer.
Huma Main Menu
 
Figure 7. Huma main menu






Huma Cinematics
The video below gives a general overview of the game and also mentions Huma II that is currently under development: 
https://www.youtube.com/watch?v=rO5e4phv-6M
Huma Level 1
On this level Huma is at the jungle looking for a transport to find the robot who created him…
 
https://www.youtube.com/watch?v=wYPIRY9UTeA
Huma Level 2
On this level Huma is in a tank, trying to find the robot, he will have tanks and helicopters has enemies, beside the droids and the genetic modified beings controlled by aliens… 
https://www.youtube.com/watch?v=n4jjyYV4-0I

Huma Level 3
On this level Huma finds himself in a desert full of enemies, he has to fight and reach the box that will take him to the next level…
 
https://www.youtube.com/watch?v=rIAxiyK9wYY
Huma Level 4
On this final level Huma in case he succeeds will find his creator that will give him the know-how on how to create humans.
 
https://www.youtube.com/watch?v=sMG61FkZ4WA
Tests
Formal Test – Unit testing.
To not crash, find bugs, not appearing error messages on run time. 
Code tests, 
API and database testing
Capability Testing
Test on Windows
User Level Testing
Check the time it takes for players to start testing and understand the contents…
Theme choice
This theme was chosen due to the technical requirements of making a game it uses an engine in this case it was cryengine and use of 3DS Max and Adobe Flash, the application runs on Windows x86.
During the development of this project several sprints were performed where it was defined the objectives of the project.
Nowadays the tendency of playing computer games with high graphic capacity is high, there are several cases of success like flappy birds, angry birds, minecraft, and the games from electronic arts, gameloft and warner bros, among many other cases.
Due to the timeline restriction, the project only has 4 type of levels and 8 types of characters, one of the levels is a city and occupies too much space and processing capacity.
The city level should run ok on higher capacity computers, although one of the objectives of the project is that the application works fine for different types of computers.
When pressing some buttons the processor takes some time to execute for example loading levels, because the levels 
have lots of information that delay the execution, although this delay time will not occur in computers with higher processor capacity.
The game uses new strategies and responses.
First person shooting games have been developing, and it is something that is easy to sell.
Nielsen Heuristics
•	Visibility of system status:
An acceptable level of visualization has been reached.
•	Match between system and the real world:
Scenarios were made based on reality. Some characters look very realistic. The water looks very real as well as the tornado and the animals
•	User control and freedom:
Difficulties in using keyboard and mouse at the same time.
•	Consistency and standards:
System crashes when playing in first person and in third person not. Zoom issues, high resolution issues. Crash does not happen for better graphical cards.
•	Error prevention:
Some functionalities were removed to avoid errors,
•	Recognition rather than recall:
•	Flexibility and efficiency of use:
Only works on x86 windows environments. Requires DLLs
•	Aesthetic. 
The image quality is high.
•	Help users recognize, diagnose, and recover from errors:
Visual studio decoder. Unit testing, etc…
•	Help and documentation:
Much documentation, user manual currently WIP
Characters used
Low level robot, because he is skinny it is hard to hit:
Crafter robot, has more health and more damage, increased difficulty when facing this robot:
  
Tin man robot, easy enemy with lower health and less hit damage and speed:
 
Manuel – A genetic modified human with a larger neck
 
Mr. Snipes – Uses a different type of weapon, dangerous on long range:
 
Secret man – a genetic modified human, that has a machine gun has weapon:
 
Huma – Main Character:
 
Figures 8, 9, 10, 11, 12, 13 and 14. Displays all the characters that appear in the game, some were made using 3DS Max
User tests
Tests were made to 7 people where they had to give a score from 0 to 100 to the types Image quality, Gameplay and Story, all the results were above 70%.
 
The correspondent values given can be seen in the table below:
 
Table 1. Table that shows the results given by users for the categories of graphic quality, story and gameplay.
Conclusions of the Tests Results
Users were able to identify the enemies and recognize the scenarios.
The story was highly appreciated by some.
It was easy to play.
Great suggestions were made:
Make 10 levels to ship the game.
Make cinematics to promote the game
Another game was shown during tests of the initial project made with unreal, the Unreal project had more fans.
Being able to play on mobile and web. 
Many requested a change of the HUD.
Some mentioned a change of the shading.
The majority gave a grade above 70% on quality terms.
Many suggestions were made and many compliments were obtained. There 
System`s limitations
This system in order to be executed it is recommended a minimum speed of 2.0 Ghz, it has been tested on Windows 8.1 and windows 10. It does not require the installation of extra libraries.
The city level because it has a city requires a high processor capacity in order to be played.
Does not require a web browser. It has a limit of the number of levels. The display size can be costumized.
It requires the use of computer and a mouse. The levels/scenarios have boundaries. When the robots are shot, they bleed. The robot, genetic modified beings and vehicles AI stay Idle when the player is not there. Requires Visual Studio, 3D Max, Flash, etc… on the dev computer.
It is running for some versions of Windows.
SYSTEM`S FUNCTIONALITIES
The system has a menu interface with a video and music. 2 Different musics were selected for this application one during the menu and another during in game. The system should have the functionalities of shooting, changing weapon, run and crouch.
The HUD should display current and maximum levels of health, it should show ammo level, oxygen and also stamina to not allow the player to run continuously.
It should have the functionalities of choosing vehicles and levels.
It has 4 scenarios, desert, city airport and jungle, and 5 optional vehicles.
The opponent robots should have an intelligent system of following points on the scenario that are not visible, it has AI path, motion and the robots have different behaviors.
It should have the functionality of changing view, there are currently 2, one that the camera is behind the player (third person), and a second one that is the first person camera.
The functionality of returning to the main menu.
The functionality of showing a congratulations panel based on trigger when the player car reaches the final check point.
Should be user friendly.
GAME COMPARISON
It has been compared the game Huma with Crysis 3, both use the same engine, Crysis 3 has more levels and cinematics. Huma has more vehicles implemented. CryEngine has been bought by Amazon and has faced several changes. Huma is easier to play because on crisis 3 the enemies have more health.
Both games have a main menu and an in game menu, Huma allows the use of multiplayer.
Huma HUD has been changed during classes.
Crysis 3 can be played on PlayStation and Xbox.
 
 
Figure 15. Comparison of the game Huma with Crysis3.
 
COMPARISON OF HUMA WITH GTA
GTA has full cities and inside buildings implemented, it also has roads, highways and a several amount of cars. Huma has more realistic looking humans.
GTA has several versions and is full of characters that act like citizens. It has several type of missions and the player can pick up cars. Huma has a limited type of vehicles and a limited type of humans and the levels are much smaller. 
 
Figure 16. Comparison of the game Huma with GTA.
 
THEORETICAL ADJUSTMENT
This project will consider future scenarios, and the development of Huma II with other technologies.

The objective is to simulate a futuristic robot battle. This simulation is based on time.

Another analysis will take in consideration the speed, the AI health and the response to the player moves.
It will have a HUD, mentioning the current levels of health, oxygen, stamina and ammo of the player and also the weapon that he is currently using.
It has the option for the AI to follow the player. 
CURRENT PROBLEM
The current problem is to develop a full game, making it functional and accordant with the requirement
The motivation is to be able to simulate a futuristic robot battle with high level of realism, and try to obtain samples of information that can be processed with logical algorithms. In order to obtain an effective system.
The system will try to simulate a battle where you control one of the players, and will have to survive and fight them back...
MARKET SEGMENTATION
The game aims for the foreign market. The majority of the target audience will be men from an age range between 18 and 70. 
The game will have a small price being accessible to people with different income.
•	For the stand alone vesion Windows 64 bits use of steam.
•	For the web by the of paypal and google payments.
•	For the mobile use of google play.
TECHNOLOGIES
The project was developed mainly in C# and also uses Lua, C++, XML, and. It uses the SDK of Visual Studio. It has several functionalities implemented.
Use of APIs for communication between different applications 
It was used also Visual Studio Flash, 3Ds Max and Notepad++.
It was used several libraries from CryEngine and assets in order to give certain functionalities, in example to change level among others
.  Figure 16. CRYENGINE logo
EXPECTED RESULTS
The expected results are to simulate a futuristic robot war close to the reality. For different time frames the AI will have the information of where the player is and the best process to fulfill an efficient attack. The levels have several AI areas. Variables like speed, health and ammo will be taken in account.
The system will measure the number of AI elements and will also mention how AI should proceed, there will be correlations between variables and statistics values for different distributions that will be generated for the different scenarios.
It will measure the player performance for each level and will look for the optimization of time. It will present several displays and graphs for the different agents…
JUSTIFY THE DEVELOPMENT TECHNOLOGY 
This project is based on developing futuristic robot battle simulator, the technology used was CryEngine due to time restrictions. Other projects were made in parallel using other engines like Unreal Engine and Unity, it has the limitation that can not be exported to mobile or web.
Many of the new games available are based in unreal engine, but this project was made in order to look the most realistic as possible, strategy followed by many of the bigger companies in the game development area like Ubisoft and Electronic Arts. 
The technology used was 3DS max for modelling and rigging, the major part of the game was made in CryEngine, it was also used OpenShot and other movie editors. 
Decided to follow C# mainly combined with C++ and Lua, and the project is not open source based, although developers vary on the opinion of which technology to be used, the project followed a strategy not based in open source technologies.
It was also used Flash and Action Script. This technology used allows to implement several game components like the menus and the HUD…
Due to high graphic quality and processing effort, the game works fine on computers with processors above 2.0 Ghz and above 6 GB of RAM.
Tested on several computers the game works fine
The tested computer which works fine was:
10nm 64-bit Octa-Core Processor *2.8GHz + 1.7GHz (Maximum Clock Speed, Performance Core + Efficiency Core)
10nm 64-bit Octa-Core Processor *2.7GHz + 1.7GHz (Maximum Clock Speed, Performance Core + Efficiency Core)
6GB RAM
The CryEngine version used was the latest build. It was upgraded during project development and allowed to place the level city which has a serious GPU consumption.
 GAME SCENARIOS
Huma Level 1 - The Jungle






Figure 17. Level 1 
Huma Level 2 - Airport







Figure 18. Level 2 
Huma Level 3 - Desert






Figure 19. Level 3
Huma Level 4 - City







Figure 20. Level 4

GAMES - SIMULATION
The game offers 4 different levels based on the simulation of a futuristic robot war. The first is based on Huma trying to cross the jungle without getting killed. The second starts in tank to help the journey in order to find the robot who created Huma. The third a desert which Huma will have to cross, The forth a city where the robot is hidden inside a cave.
The main keys for movement are: d - right, a - left, w - up and s – down.
The objective is to reach the final level.
It has several parameters like speed, shooting, moving backwards, turning
HOW TO RESOLVE THE PROBLEM
The current problem is to develop a full game, making it functional and accordant with the requirement
The motivation is to be able to simulate a futuristic robot battle with high level of realism, and try to obtain samples of information that can be processed with logical algorithms. In order to obtain an effective system.
The system will try to simulate a battle where you control one of the players, and will have to survive and fight them back...
FUTURE WORK
•	Intention of building a multigame web platform, where games by phone and for PC can be downloaded.
•	The web platform has a user management module.
•	A web platform similar to congregate and miniclip but with games with better quality
•	A second variant of the future work is to use Azure or AWS where via web the player can play high quality AAA games without installing anything on the computer.
ANALYSIS
This Project is based on replicating real events into an animation that describes the behavior of elements and how they interact with the environment.
It was used different types of render and different software for imaging treatment, and for the processing and sequencing of different units.
PARAMETERS AND ENTITIES
It has several parameters like speed, shooting, moving backwards, turning, isIdle, LevelID, PlayeID among others, there are at least 10 AI entities, the AI tank only move around the AI area defined on the scenario, the AI for each level has different wave points, in general for each level were used around 40 AI wave points.
The player entity has several scripts for controlling and interacting with the camera and the keyboard interface.
There was set several parameters like maximum speed, maximum health, for quaternions (when turning) and the camera changes position according mouse movement and player position.
FLOWGRAPH
Example used for implementing the HUD in the game:
 CONCLUSION
This project was developed for the curricular unit of Interactive applications, game development and multimedia management. It is intended to simulate a futuristic robot game wars has analogy to the game Star Wars of Electronic Arts.
It has several scenarios, make several analysis and achieve different results according to different factors.
Many parameters were used in order to make it seem more realistic. It also offers the option to save / load the game and multiplayer.
The change of parameters is very important because it will report different values.
This system is made in order to provide different simulations, the programming languages used were C#, C++, Lua, among others…
The main goal is to provide fun to the users and obtain different results for different assumptions and different parameters.
This project is based in getting realistic graphics and adapting different types of artificial intelligences for different contexts, it required a deep understanding and knowledge of C# and also an extensive knowledge of several tools like 3DS Max and Adobe Flash, Action Script was used, and aslo an API passing objects in the XML format.
It was required the use of several scripts and the development was continuous. On the beginning of the project other game engines were used like Unreal Engine and Unity, some of the cinematics were made via Unity and Adobe After Effects.
Huma is a story about machine learning and how robots would be more like humans, it has several scenarios, and several vehicles.
It was implemented a stamina / running system as well as a HUD and other mechanism to make the game easier to play, in the project we can find different types of artificial intelligences, for example the crafters have higher health and a different weapon system.
This was developed under an university scope, under the theme of MSc in Informatics Engineering.
ACKNOWLEDGMENTS
Gratitude to the several testers and a special thanks for Collin Bishop from CryEngine and Frank Himmerman ex-colleague from Microsoft for the help provided during the course of the development of this game, both gave important feedback and participated in the development of games like Crysis 2 and Halo.
REFERENCES
1.	CryENGINE 3 Game Development: Beginner's Guide Paperback – September 21, 2012
by Sean Tracy (Author), Paul Reindell (Author)
2.	CryENGINE Game Programming with C++, C#, and Lua Paperback – November 22, 2013
by Filip Lundgren (Author), Ruan Pearce-Authers (Author) 
3.	The Beginner's Guide to Rigging in 3ds Max 2018
3D Rigging: Build the Skills Needed to Start Rigging you Own Characters TODAY by Anass Cherkaoui



![image](https://github.com/user-attachments/assets/c00e2271-4f58-4a40-80a7-3e93144f5558)


CODE USED
Example of some of the classes used: Class Player.cs
namespace CryEngine.Game
{
	[EntityComponent(Guid = "2d0518e2-022a-a22f-4195-62c7eb1be031")]
	public class Player : EntityComponent
	{
		public enum GeometrySlots
		{
			ThirdPerson = 0
		}

		private const string PlayerMaterialUrl = "%ENGINE%/EngineAssets/TextureMsg/DefaultSolids";

		[SerializeValue]
		private float _mass = 90.0f;

		private PlayerView _playerView;

		/// <summary>
		/// Mass of the player entity in kg.
		/// </summary>
		/// <value>The mass.</value>
		[EntityProperty(0, "Mass of the player entity in kg.")]
		public float Mass
		{
			get
			{
				return _mass;
			}
			set
			{
				_mass = value;
				PrepareRigidbody();
			}
		}

		/// <summary>
		/// Strength of the per-frame impulse when holding inputs
		/// </summary>
		/// <value>The move impulse strength.</value>
		[EntityProperty(0, "Strength of the per-frame impulse when holding inputs")]
		public float MoveImpulseStrength{ get; set; } = 800.0f;

		/// <summary>
		/// Speed at which the player rotates entity yaw
		/// </summary>
		/// <value>The rotation speed yaw.</value>
		[EntityProperty(0, "Speed at which the player rotates entity yaw")]
		public float RotationSpeedYaw{ get; set; } = 0.002f;

		/// <summary>
		/// Speed at which the player rotates entity pitch
		/// </summary>
		/// <value>The rotation speed pitch.</value>
		[EntityProperty(0, "Speed at which the player rotates entity pitch")]
		public float RotationSpeedPitch{ get; set; } = 0.002f;

		/// <summary>
		/// Minimum entity pitch limit
		/// </summary>
		/// <value>The rotation limits minimum pitch.</value>
		[EntityProperty(0, "Minimum entity pitch limit")]
		public float RotationLimitsMinPitch{ get; set; } = -0.84f;

		/// <summary>
		/// Maximum entity pitch limit
		/// </summary>
		/// <value>The rotation limits max pitch.</value>
		[EntityProperty(0, "Maximum entity pitch limit")]
		public float RotationLimitsMaxPitch{ get; set; } = 1.5f;

		/// <summary>
		/// Determines the distance between player and camera
		/// </summary>
		/// <value>The view distance.</value>
		[EntityProperty(0, "Determines the distance between player and camera")]
		public float ViewDistance{ get; set; } = 10.0f;

		protected override void OnInitialize()
		{
			base.OnInitialize();

			Initialize();
		}

		protected override void OnGameplayStart()
		{
			base.OnGameplayStart();

			// It is possible that there were changes made during the last time the gamemode was started and now.
			// To prevent any weird behaviour we initialize again just in case.
			Initialize();
		}

		private void Initialize()
		{
			// Prepare the visuals of the player
			SetPlayerModel();

			// Now create the physical representation of the entity
			PrepareRigidbody();

			_playerView = new PlayerView(this);
		}

		protected override void OnUpdate(float frameTime)
		{
			base.OnUpdate(frameTime);

			UpdateMovement(frameTime);

			_playerView.UpdateView(frameTime);
		}

		private void UpdateMovement(float frameTime)
		{
			var entity = Entity;
			var physicalEntity = entity.Physics;
			if(physicalEntity == null)
			{
				return;
			}
				
			var moveForward = Input.KeyDown(KeyId.W);
			var moveBack = Input.KeyDown(KeyId.S);
			var moveLeft = Input.KeyDown(KeyId.A);
			var moveRight = Input.KeyDown(KeyId.D);

			//We need to transform the input-direction to camera-space, so we use the forward of the camera to calculate the proper direction.
			var forward = Camera.ForwardDirection;

			//Cross the forward of the camera with Vector3.up, so we get the right-direction of the camera.
			//The forward is flatten on the z-axis, so we don't have to worry about the sphere being pushed up or down.
			var flatForward = forward;
			flatForward.Z = 0.0f;
			flatForward = flatForward.Normalized;
			var right = flatForward.Cross(Vector3.Up);

			Vector3 impulse = Vector3.Zero;

			// Go through the inputs and apply an impulse corresponding to view rotation
			if(moveForward)
			{
				impulse += flatForward * MoveImpulseStrength;
			}
			if(moveBack)
			{
				impulse -= flatForward * MoveImpulseStrength;
			}
			if(moveLeft)
			{
				impulse -= right * MoveImpulseStrength;
			}
			if(moveRight)
			{
				impulse += right * MoveImpulseStrength;
			}

			// Only dispatch the impulse to physics if one was provided
			if(impulse.LengthSquared > 0.0f)
			{
				// Multiply by frame time to keep consistent across machines
				impulse *= frameTime;

				physicalEntity.AddImpulse(impulse);
			}
		}

		private void SetPlayerModel()
		{
			var entity = Entity;

			// Load the sphere model
			entity.LoadGeometry((int)GeometrySlots.ThirdPerson, Primitives.Sphere);

			// Override material so that we can see the ball rolling more easily
			entity.LoadMaterial(PlayerMaterialUrl);
		}

		private void PrepareRigidbody()
		{
			var physicsEntity = Entity.Physics;
			if(physicsEntity == null)
			{
				return;
			}

			// Physicalize the player as type Living.
			// This physical entity type is specifically implemented for players
			physicsEntity.Physicalize(Mass, PhysicalizationType.Rigid);
		}
	}
}

Class Camera.cs
// Copyright 2001-2018 Crytek GmbH / Crytek Group. All rights reserved.

using System.Runtime.CompilerServices;
using CryEngine.Common;
using CryEngine.Rendering;

namespace CryEngine
{
	/// <summary>
	/// Static class exposing access to the current view camera
	/// </summary>
	public static class Camera
	{
		/// <summary>
		/// Set or get the position of the current view camera.
		/// </summary>
		public static Vector3 Position
		{
			get
			{
				return Engine.System.GetViewCamera().GetPosition();
			}
			set
			{
				Engine.System.GetViewCamera().SetPosition(value);
			}
		}

		/// <summary>
		/// Get or set the facing direction of the current view camera.
		/// </summary>
		public static Vector3 ForwardDirection
		{
			get
			{
				return Engine.System.GetViewCamera().GetMatrix().GetColumn1();
			}
			set
			{
				var camera = Engine.System.GetViewCamera();
				var newRotation = new Quaternion(value);

				camera.SetMatrix(new Matrix3x4(Vector3.One, newRotation, camera.GetPosition()));
			}
		}

		/// <summary>
		/// Get or set the transformation matrix of the current view camera.
		/// </summary>
		public static Matrix3x4 Transform
		{
			get
			{
				return Engine.System.GetViewCamera().GetMatrix();
			}
			set
			{
				Engine.System.GetViewCamera().SetMatrix(value);
			}
		}

		/// <summary>
		/// Get or set the rotation of the current view camera
		/// </summary>
		public static Quaternion Rotation
		{
			get
			{
				return new Quaternion(Engine.System.GetViewCamera().GetMatrix());
			}
			set
			{
				var camera = Engine.System.GetViewCamera();

				camera.SetMatrix(new Matrix3x4(Vector3.One, value, camera.GetPosition()));
			}
		}

		/// <summary>
		/// The amount of horizontal pixels this camera is currently rendering.
		/// </summary>
		public static int RenderWidth
		{
			get
			{
				var camera = Engine.System.GetViewCamera();
				return camera.GetViewSurfaceX();
			}
		}

		/// <summary>
		/// The amount of vertical pixels this camera is currently rendering.
		/// </summary>
		public static int RenderHeight
		{
			get
			{
				var camera = Engine.System.GetViewCamera();
				return camera.GetViewSurfaceZ();
			}
		}

		/// <summary>
		/// Gets or sets the field of view of the view camera in degrees.
		/// </summary>
		/// <value>The field of view.</value>
		public static float FieldOfView
		{
			get
			{
				return MathHelpers.RadiansToDegrees(Engine.System.GetViewCamera().GetFov());
			}
			set
			{
				var camera = Engine.System.GetViewCamera();

				camera.SetFrustum(camera.GetViewSurfaceX(), camera.GetViewSurfaceZ(), MathHelpers.DegreesToRadians(value));
			}
		}

		/// <summary>
		/// Converts a viewport point to a position in world-space.
		/// </summary>
		/// <param name="x">Horizontal viewport position.</param>
		/// <param name="y">Vertical viewport position.</param>
		/// <param name="depth">Depth of the viewport point.</param>
		/// <param name="position">Position of the viewport point in world-space.</param>
		/// <returns><c>true</c> if the viewport point could be converted, <c>false</c> otherwise.</returns>
		public static bool ViewportPointToWorldPoint(float x, float y, float depth, out Vector3 position)
		{
			var camera = Engine.System.GetViewCamera();
			int width = camera.GetViewSurfaceX();
			int height = camera.GetViewSurfaceZ();
			int screenX = (int)(width * x + 0.5f);
			int screenY = (int)(height * y + 0.5f);

			Vec3 result = new Vec3();
			bool visible = camera.Unproject(new Vec3(x, height - y, depth), result);
			position = result;
			return visible;
		}

		/// <summary>
		/// Converts a viewport point to a position in world-space.
		/// </summary>
		/// <param name="viewportPoint">Viewport point that will be converted.</param>
		/// <param name="depth">Depth of the viewport point.</param>
		/// <param name="position">Position of the viewport point in world-space.</param>
		/// <returns><c>true</c> if the viewport point could be converted, <c>false</c> otherwise.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static bool ViewportPointToWorldPoint(Vector2 viewportPoint, float depth, out Vector3 position)
		{
			return ViewportPointToWorldPoint(viewportPoint.x, viewportPoint.y, depth, out position);
		}

		/// <summary>
		/// Converts a viewport point to a direction in world-space.
		/// </summary>
		/// <param name="x">Horizontal viewport position.</param>
		/// <param name="y">Vertical viewport position.</param>
		/// <param name="direction">Direction into world-space.</param>
		/// <returns><c>true</c> if the viewport point could be converted, <c>false</c> otherwise.</returns>
		public static bool ViewportPointToDirection(float x, float y, out Vector3 direction)
		{
			var camera = Engine.System.GetViewCamera();
			int width = camera.GetViewSurfaceX();
			int height = camera.GetViewSurfaceZ();
			int screenX = (int)(width * x + 0.5f);
			int screenY = (int)(height * y + 0.5f);

			Vec3 result = new Vec3();
			bool visible = camera.Unproject(new Vec3(x, height - y, 1), result);
			var position = result;
			direction = (position - Position).Normalized;
			return visible;
		}

		/// <summary>
		/// Converts a viewport point to a direction in world-space.
		/// </summary>
		/// <param name="viewportPoint">Viewport point that will be converted.</param>
		/// <param name="direction">Direction into world-space.</param>
		/// <returns><c>true</c> if the viewport point could be converted, <c>false</c> otherwise.</returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static bool ViewportPointToDirection(Vector2 viewportPoint, out Vector3 direction)
		{
			return ViewportPointToDirection(viewportPoint.x, viewportPoint.y, out direction);
		}

		/// <summary>
		/// Converts a screen position to a position in world-space.
		/// </summary>
		/// <param name="x">Horizontal position on the screen.</param>
		/// <param name="y">Vertical position on the screen.</param>
		/// <param name="depth">Depth of the screenpoint.</param>
		/// <param name="position">Position of the screenpoint in world-space.</param>
		/// <returns><c>true</c> if the screenpoint could be converted, <c>false</c> otherwise.</returns>
		public static bool ScreenPointToWorldPoint(int x, int y, float depth, out Vector3 position)
		{
			var camera = Engine.System.GetViewCamera();
			Vec3 result = new Vec3();
			bool visible = camera.Unproject(new Vec3(x, camera.GetViewSurfaceZ() - y, depth), result);
			position = result;
			return visible;
		}

		/// <summary>
		/// Converts a screen position to a direction in world-space.
		/// </summary>
		/// <param name="x">Horizontal position on the screen.</param>
		/// <param name="y">Vertical position on the screen.</param>
		/// <param name="direction">Direction into world-space.</param>
		/// <returns><c>true</c> if the screenpoint could be converted, <c>false</c> otherwise.</returns>
		public static bool ScreenPointToDirection(int x, int y, out Vector3 direction)
		{
			var camera = Engine.System.GetViewCamera();
			Vec3 result = new Vec3();
			bool visible = camera.Unproject(new Vec3(x, camera.GetViewSurfaceZ() - y, 1), result);
			var position = result;
			direction = (position - Position).Normalized;
			return visible;
		}

		/// <summary>
		/// Converts a point in world-space to the camera's screen-space.
		/// </summary>
		/// <returns><c>true</c>, if the point is visible, <c>false</c> otherwise.</returns>
		/// <param name="position">Position of the point in world-space.</param>
		/// <param name="screenPosition">Position of the point in the camera's screen-space.</param>
		public static bool WorldPointToScreenPoint(Vector3 position, out Vector3 screenPosition)
		{
			var camera = Engine.System.GetViewCamera();
			Vec3 result = new Vec3();
			var visible = camera.Project(position, result);
			screenPosition = result;
			return visible;
		}

		/// <summary>
		/// Converts a point in world-space to the camera's viewport-space.
		/// </summary>
		/// <returns><c>true</c>, if the point is visible, <c>false</c> otherwise.</returns>
		/// <param name="position">Position of the point in world-space.</param>
		/// <param name="viewportPosition">Position of the point in the camera's viewport-space.</param>
		public static bool WorldPointToViewportPoint(Vector3 position, out Vector3 viewportPosition)
		{
			var camera = Engine.System.GetViewCamera();
			Vec3 result = new Vec3();
			var visible = camera.Project(position, result);
			viewportPosition = result;
			viewportPosition.x /= camera.GetViewSurfaceX();
			viewportPosition.y /= camera.GetViewSurfaceZ();
			return visible;
		}

		/// <summary>
		/// Transforms a direction from world space to local space of the camera.
		/// </summary>
		/// <param name="direction"></param>
		/// <returns></returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static Vector3 TransformDirection(Vector3 direction)
		{
			return Rotation * direction;
		}
	}
}
Class LookAtSimple.h
// Copyright 2001-2018 Crytek GmbH / Crytek Group. All rights reserved.

#ifndef LookAtSimple_h
#define LookAtSimple_h

#include <CryExtension/ClassWeaver.h>

namespace AnimPoseModifier {

class CRY_ALIGN(32) CLookAtSimple:
	public IAnimationPoseModifier
{
private:
	struct State
	{
		int32 jointId;
		Vec3  jointOffsetRelative;
		Vec3  targetGlobal;
		f32   weight;
	};

public:
	CRYINTERFACE_BEGIN()
	CRYINTERFACE_ADD(IAnimationPoseModifier)
	CRYINTERFACE_END()

	CRYGENERATE_CLASS_GUID(CLookAtSimple, "AnimationPoseModifier_LookAtSimple", "ba7e2a80-9970-435f-b667-9c08df616d74"_cry_guid);

	CLookAtSimple();
	virtual ~CLookAtSimple() {}

public:
	void SetJointId(uint32 id)                      { m_state.jointId = id; }
	void SetJointOffsetRelative(const Vec3& offset) { m_state.jointOffsetRelative = offset; }

	void SetTargetGlobal(const Vec3& target)        { m_state.targetGlobal = target; }

	void SetWeight(f32 weight)                      { m_state.weight = weight; }

private:
	bool ValidateJointId(IDefaultSkeleton & pModelSkeleton);

	// IAnimationPoseModifier
public:
	virtual bool Prepare(const SAnimationPoseModifierParams &params) override;
	virtual bool Execute(const SAnimationPoseModifierParams &params) override;
	virtual void Synchronize() override;

	void GetMemoryUsage(ICrySizer* pSizer) const override
	{
		pSizer->AddObject(this, sizeof(*this));
	}

private:
	State m_state;
	State m_stateExecute;
};

} // namespace AnimPoseModifier

#endif // LookAtSimple_h

Class Main.lua
function OnInit()
	Script.ReloadScript("scripts/common.lua");
	Script.ReloadScript("scripts/Tweaks.lua");
end

function OnShutdown()
end

Class Main.lua
function OnInit()


